#!/bin/sh
set -e
export -n CDPATH

. "$LOAD_SHARED_PATH"

printf "Creating new base in: %s" "$FIRE_REGION"

load_shared functions

create_route_table() {
  # create route-table and save new table's ID in a variable
  rt_id="$(aws_exec ec2 create-route-table \
    --tag-specifications "ResourceType=route-table,
      Tags=[
       {Key=\"${FIRE_PROJECT}:${FIRE_PROGRAM_NAME}-environment\",Value=\"${FIRE_ENVIRONMENT}\"},
      ]" \
    --vpc-id "$(get_vpc_info vpc_id)" \
    --query "RouteTable.RouteTableId" --output text)"
  aws_exec ec2 create-route \
    --route-table-id "$rt_id" \
    --destination-cidr-block "0.0.0.0/0" \
    --gateway-id "$(get_internet_gateway_info internet_gateway_id)"
  aws_exec ec2 create-route \
    --route-table-id "$rt_id" \
    --destination-ipv6-cidr-block "::/0" \
    --gateway-id "$(get_internet_gateway_info internet_gateway_id)"
  aws_exec ec2 associate-route-table \
    --route-table-id "$rt_id" \
    --subnet-id "$(get_subnet_info subnet_id)"
}

create_internet_gateway() {
  ig_id="$(aws_exec ec2 create-internet-gateway \
    --tag-specifications "ResourceType=internet-gateway,
      Tags=[
       {Key=\"${FIRE_PROJECT}:${FIRE_PROGRAM_NAME}-environment\",Value=\"${FIRE_ENVIRONMENT}\"},
      ]" \
    --query "InternetGateway.InternetGatewayId" --output text)"
  aws_exec ec2 attach-internet-gateway --vpc-id "$(get_vpc_info vpc_id)" --internet-gateway-id "$ig_id"
  echo "$ig_id" >"$FIRE_BASE_INTERNET_GATEWAY_FILE"
}

create_vpc() {
  aws_exec ec2 create-vpc \
    --cidr-block 192.168.0.0/16 \
    --tag-specifications "ResourceType=vpc,
      Tags=[{Key=
      \"${FIRE_PROJECT}:${FIRE_PROGRAM_NAME}-environment\",Value=\"${FIRE_ENVIRONMENT}\"}]"\
    --query "Vpc.VpcId" --output text \
    1> /dev/null 2>&1
  until [ "$(get_vpc_info state)" = "available" ]; do
    sleep 1
    clear_vpc_information
  done
  main_rt_id="$(aws_exec ec2 describe-route-tables \
    --filter "Name=association.main,Values=true" \
             "Name=vpc-id,Values=$(get_vpc_info vpc_id)" \
    --query "RouteTables[].RouteTableId" --output text)"
  aws_exec ec2 create-tags --resources "$main_rt_id" \
    --tags "Key=\"${FIRE_PROJECT}:${FIRE_PROGRAM_NAME}-environment\",Value=\"${FIRE_ENVIRONMENT}\""
}

create_subnet() {
  aws_exec ec2 create-subnet \
    --cidr-block 192.168.0.0/20 \
    --vpc-id "$(get_vpc_info vpc_id)" \
    --tag-specifications "ResourceType=subnet,
      Tags=[
        {Key=\"${FIRE_PROJECT}:${FIRE_PROGRAM_NAME}-environment\",Value=\"${FIRE_ENVIRONMENT}\"}
      ]" \
    1> /dev/null 2>&1
  until [ "$(get_subnet_info state)" = "available" ]; do
    sleep 1
    clear_subnet_information
  done
}

create_key_pair() {
  if [ -z "$FIRE_PUBLIC_KEY_FILE" ]; then
    aws_exec ec2 create-key-pair \
      --key-name "${FIRE_PROJECT}:${FIRE_PROGRAM_NAME}:${FIRE_ENVIRONMENT}" \
      --tag-specifications "ResourceType=key-pair,
        Tags=[
         {Key=\"${FIRE_PROJECT}:${FIRE_PROGRAM_NAME}-environment\",Value=\"${FIRE_ENVIRONMENT}\"},
         {Key=\"${FIRE_PROJECT}:${FIRE_PROGRAM_NAME}-role\",Value=base}
        ]" \
      1> /dev/null 2>&1
  else
    aws_exec ec2 import-key-pair \
      --key-name "${FIRE_PROJECT}:${FIRE_PROGRAM_NAME}:${FIRE_ENVIRONMENT}" \
      --public-key-material "fileb://${FIRE_PUBLIC_KEY_FILE}" \
      --tag-specifications "ResourceType=key-pair,
        Tags=[
         {Key=\"${FIRE_PROJECT}:${FIRE_PROGRAM_NAME}-environment\",Value=\"${FIRE_ENVIRONMENT}\"},
         {Key=\"${FIRE_PROJECT}:${FIRE_PROGRAM_NAME}-role\",Value=base}
        ]" \
      1> /dev/null 2>&1
  fi
}

create_security_group() {
  group_id=$(aws_exec ec2 create-security-group \
    --group-name "${FIRE_PROJECT}:${FIRE_PROGRAM_NAME}:${FIRE_ENVIRONMENT}" \
    --vpc-id "$(get_vpc_info vpc_id)" \
    --description "${FIRE_PROGRAM_NAME} base security group" \
    --tag-specifications "ResourceType=security-group,
      Tags=[
       {Key=\"${FIRE_PROJECT}:${FIRE_PROGRAM_NAME}-environment\",Value=\"${FIRE_ENVIRONMENT}\"},
       {Key=\"${FIRE_PROJECT}:${FIRE_PROGRAM_NAME}-role\",Value=base}
      ]" \
    --query "GroupId" --output text
  )
  add_ingress_port_to_security_group "$group_id" 22
  add_ingress_port_to_security_group "$group_id" 80
  add_ingress_port_to_security_group "$group_id" 443
}

add_ingress_port_to_security_group() {
  aws_exec ec2 authorize-security-group-ingress \
    --group-id "$1" \
    --ip-permissions "IpRanges=[{CidrIp=\"0.0.0.0/0\"}],Ipv6Ranges=[{CidrIpv6=\"::/0\"}],
                      FromPort=$2,ToPort=$2,IpProtocol=tcp"
}

create_instance() {
  image_id="$(aws ec2 describe-images \
    --output text --owners amazon --filters "Name=name,Values=amzn*" \
    --query "Images[?starts_with(Name, \`\"amzn2-ami-hvm-\"\`)] 
             | sort_by(@, &CreationDate)[-1].ImageId")"
  aws_exec ec2 run-instances \
    --block-device-mappings "DeviceName=/dev/xvda,Ebs={VolumeSize=8}" \
    --image-id "$image_id" \
    --instance-type t2.nano \
    --subnet-id "$(get_subnet_info subnet_id)" \
    --security-group-ids "$(get_security_group_info group_id)" \
    --count 1 \
    --key-name "$(get_key_pair_info key_name)" \
    --tag-specifications "ResourceType=instance,
      Tags=[
       {Key=\"${FIRE_PROJECT}:${FIRE_PROGRAM_NAME}-environment\",Value=\"${FIRE_ENVIRONMENT}\"},
       {Key=\"${FIRE_PROJECT}:${FIRE_PROGRAM_NAME}-role\",Value=base}
      ]" \
    --network-interfaces AssociatePublicIpAddress=true,DeviceIndex=0
}

get_vpc_info vpc_id
if [ -z "$(get_vpc_info vpc_id)" ]; then
  clear_vpc_information
  create_vpc
fi

get_subnet_info subnet_id
if [ -z "$(get_subnet_info subnet_id)" ]; then
  clear_subnet_information
  create_subnet
fi

get_key_pair_info key_name
if [ -z "$(get_key_pair_info key_name)" ]; then
  clear_base_key_pair_information
  create_key_pair
fi

get_security_group_info group_id
if [ -z "$(get_security_group_info group_id)" ]; then
  clear_base_security_group_information
  create_security_group
fi

get_base_instance_info instance_id
if [ -z "$(get_base_instance_info instance_id)" ]; then
  clear_base_instance_information
  create_instance
fi

get_internet_gateway_info internet_gateway_id
if [ -z "$(get_internet_gateway_info internet_gateway_id)" ]; then
  echo "inside internet gateway"
  clear_internet_gateway_information
  create_internet_gateway
fi

get_route_table_info route_table_id
if [ -z "$(get_route_table_info route_table_id)" ]; then
  clear_route_table_information
  create_route_table
fi
